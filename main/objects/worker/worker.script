local defgraph = require("defgraph.defgraph")
local gamestate = require("data.gamestate")

local get_nearest_fire_node_and_id
local find_next_fire

function find_next_fire(self)
	if next(self.touching_fire_cols) ~= nil then
		-- extinguish the other fires first and remove them from touching_fire_cols
		for k, v in pairs(self.touching_fire_cols) do
			msg.post(v, "extinguish")
			self.touching_fire_cols[v] = nil
		end
	end

	msg.post("#", "find_next_fire")
end

function get_nearest_fire_node_and_id(self)
	local pos = go.get_position()
	
	-- create copy of table for sorting, since it sorts in-place
	local fires_copy = table.shallowcopy(gamestate.fires)

	table.sort(fires_copy, function(pos1, pos2)
		-- get distance between pos1 and the worker, then pos2 and the worker, and return a check between those distances
		local distance1 = go.get_position(pos1) - pos
		local distance2 = go.get_position(pos2) - pos
		return vmath.length(distance1) < vmath.length(distance2)
	end)

	-- get first key in the table
	local first_key
	for k in pairs(fires_copy) do
		first_key = k
		break
	end

	local new_url = msg.url(nil, fires_copy[first_key], "fire")
	return go.get(new_url, "worker_node"), first_key
end

local function alert_state(self, handle, elapsed)
	self.standing_in_place = false
	msg.post(self.fire_col_id, "get_worker_node")
	self.movement_data = defgraph.move_initialize(go.get_position(), { gamestate.extinguishers_worker_node })
end

function init(self)
	self.walk_speed = 50
	self.run_speed = 100
	self.is_alerted = false
	self.standing_in_place = false
	self.is_carrying_extinguisher = false

	self.fire_col_id = nil
	self.next_fire_id = nil
	self.next_fire_node = nil

	self.touching_fire_cols = {}

	-- insert every node into this table so the worker can navigate to all of them
	self.all_nodes = {}
	for i = 1, 30 do
		table.insert(self.all_nodes, i)
	end
	
	self.movement_data = defgraph.move_initialize(go.get_position(), self.all_nodes, defgraph.ROUTETYPE.SHUFFLE)
	self.move_result = nil
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		if message.group == hash("fire") then
			if message.enter then
				self.touching_fire_cols[message.other_id] = message.other_id
				local url = msg.url(nil, message.other_id, "fire_collision")
				local fire_id = go.get(url, "fire_id")
				if self.is_carrying_extinguisher and fire_id == self.next_fire_id then
					-- extinguish and find another fire node if possible
					msg.post(fire_id, "extinguish")
					self.touching_fire_cols[message.other_id] = nil
					find_next_fire(self)
				elseif not self.is_alerted then
					self.is_alerted = true
					self.standing_in_place = true
					self.fire_col_id = message.other_id
					
					local url = msg.url(nil, message.other_id, "fire_collision")
					local fire_id = go.get(url, "fire_id")
					self.next_fire_id = fire_id
					timer.delay(1, false, alert_state)
				end
			else
				self.touching_fire_cols[message.other_id] = nil
			end
		elseif message.group == hash("extinguishers") and message.enter and self.is_alerted then
			self.is_carrying_extinguisher = true
			self.movement_data = defgraph.move_initialize(go.get_position(), { self.next_fire_node })
		end
	elseif message_id == hash("worker_node_response") then
		self.next_fire_node = message.worker_node
	elseif message_id == hash("find_next_fire") then
		local new_node, new_id = get_nearest_fire_node_and_id(self)
		self.next_fire_id = new_id
		self.movement_data = defgraph.move_initialize(go.get_position(), { new_node })
	end
end

function update(self, dt)
	if not self.standing_in_place then
		if self.is_alerted then
			self.movement_data, self.move_result = defgraph.move_player(go.get_position(), self.run_speed * dt, self.movement_data)
		else
			self.movement_data, self.move_result = defgraph.move_player(go.get_position(), self.walk_speed * dt, self.movement_data)
		end
	end

	if self.move_result then
		go.set_position(self.move_result.position)
		--defgraph.debug_draw_player_move(self.movement_data, vmath.vector4(1, 1, 0, 1))
	end
end